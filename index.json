[{"content":"Have you ever wondered how to build an image search engine (like Google Images, Myntra fashion products search, etc,.)? In this blog post we will create a simple image search feature in the Ruby on Rails application using Weaviate vector database. The modern approach to implementing image search involves vector embeddings. Leveraging the magic of neural networks and vector databases, we\u0026rsquo;ll explore how to realize vector-based image searching.\nThe popularity of vector search databases has skyrocketed recently, especially for vector conversion, storage, and retrieval tasks. In this blog post, we will specifically explore one such database called Weaviate, which offers neural network models like Resnet-50(embedding model) for vectorization.\nWhat is a vector database? Type of database, that stores date as a high-dimensional value. Working with vector embeddings is more complex and the traditional databases can\u0026rsquo;t keep up with it for providing insights and real-time analysis with the data. That\u0026rsquo;s where vector DBs come into play, these are designed for handling this type of data and offer the performance, scalability, and flexibility you need to make the most out of your data.\nThe flow will be like, first we use the embedding model to create vectors from the content, next the vector embeddings of the content is inserted into the vector database, with some reference to the original content. Now using an application we will interact with the vector DB via the embedding model, like on issuing a query we use the same embedding model to create embeddings for the query and use those to query the database for similar vector embeddings.\nOur focus will be on constructing a fashion product search based on images, and to accomplish this, we will utilize the Myntra fashion products dataset from Kaggle. Make sure to download the dataset from the provided link, as we intend to build an image search application within our Ruby on Rails environment.\nHere are the high-level steps we\u0026rsquo;re going to follow:\nImplement the FashionProduct entity with active storage attachment (product_image) Import the dataset from Kaggle into the fashion_products table of our application. Set up Weaviate using Docker and integrate the Weaviate to ROR application using weaviate-ruby gem. Create a FashionProduct class in the Weaviate client and upload the FashionProduct records from PostgreSQL to Weaviate DB. Develop a user interface with image search functionality, making use of the Weaviate Client\u0026rsquo;s query API capabilities. Let\u0026rsquo;s start off with creating a new Rails application (used Rails 7.0.6 and Ruby 3.2.2 for this project). We will be using docker for the application and database environments (refer to the current blog\u0026rsquo;s github repo for local setup).\nrails new fashion_products_vdb --database postgresql Initialize ActiveStorage for the project\nrails active_storage:install rails db:migrate this should create the required tables for the ActiveStorage attachments. Since we are using local docker setup for active_storage attachments it will work using the local storage and doesn\u0026rsquo;t require any cloud providers setup.\nNext, let\u0026rsquo;s handle the FashionProduct entity,\nCreate model migration for the FashionProduct entity rails g model FashionProduct modify the migration and the model files with the below code.\n# db/migrate/\u0026lt;timestamp\u0026gt;_create_fashion_products.rb class CreateFashionProducts \u0026lt; ActiveRecord::Migration[7.0] def change create_table :fashion_products do |t| # Product ID from the dataset t.integer :p_id # Metadata of the products from the dataset t.string :gender t.string :master_category t.string :sub_category t.string :article_type t.string :base_colour t.string :name t.string :usage t.timestamps end end end # app/models/fashion_product.rb class FashionProduct \u0026lt; ApplicationRecord has_one_attached :product_image end The FashionProduct entity should have one ActiveStorage attachment has_one_attached :product_image to attach the image data from the dataset.\nNow migrate the fashion products data from the data set to the FashionProduct entity. For this, we need to set up a temporary volume for our application\u0026rsquo;s docker service,\nfashion_products_vdb-web: ... volumes: - .:/fashion_products_vdb - ./dataset:/dataset # Use this volume setup one time for the image dataset import process ... then place the downloaded dataset (images directory and styles.csv file) into the dataset folder created under the projects\u0026rsquo; root folder fashion_products_vdb/dataset. Restart the server, now the files under the dataset folder will be present inside the docker container (through volume config).\nNow create a service class which process importing the data from the dataset folder to application\u0026rsquo;s database.\n# app/services/import_fashion_product_data_service.rb require \u0026#39;csv\u0026#39; class ImportFashionProductDataService def initialize(dataset_path, metadata_file_name, image_dir) @dataset_path = dataset_path @csv_metadata_path = File.join(@dataset_path, metadata_file_name) @image_dir = File.join(@dataset_path, image_dir) end def call process_csv_data_import end private def process_csv_data_import line_number = 0 begin CSV.foreach(@csv_metadata_path, headers: true) do |row_data| create_fashion_prd_from_metadata(format_metadata(row_data)) line_number += 1 end rescue StandardError =\u0026gt; e puts \u0026#34;Error parsing CSV at line #{line_number}: #{e.message}\u0026#34; end end # Create a new record with the image from CSV metadata def create_fashion_prd_from_metadata(metadata) fsprd = create_fashion_prd_with(attributes: metadata) # Image attachment process image_file = File.join(@image_dir, fsprd.p_id.to_s + \u0026#39;.jpg\u0026#39;) puts image_file return unless File.exist?(image_file) fsprd.product_image.attach(io: File.open(image_file), filename: File.basename(image_file)) fsprd.save puts \u0026#34;#{fsprd.name} created successfully.\u0026#34; end def format_metadata(row_data) metadata = row_data.to_hash metadata = metadata.transform_keys do |k| case k.to_s when \u0026#39;productDisplayName\u0026#39; \u0026#39;name\u0026#39; when \u0026#39;id\u0026#39; \u0026#39;p_id\u0026#39; else k.to_s.underscore end end metadata end def create_fashion_prd_with(attributes:) FashionProduct.new.tap do |record| attributes.each do |k, v| next unless record.respond_to?(k + \u0026#39;=\u0026#39;) record.send(k + \u0026#39;=\u0026#39;, v) end end end end The above service class will loop over all the rows inside the styles.csv from the dataset which contains the product metadata and takes the corresponding image from the images folder (via the product\u0026rsquo;s id in the CSV file) and creates the FashionProduct entry with those data.\nOpen rails console and call the service class instance\u0026rsquo;s call method once to import the data to the application\u0026rsquo;s database.\ndocker-compose exec fashion_products_vdb-web bash =\u0026gt; rails console ImportFashionProductDataService.new(\u0026#39;\\dataset\u0026#39;, \u0026#39;styles.csv\u0026#39;, \u0026#39;images\u0026#39;) Now we are moving to the Weaviate integration part, for the Weaviate client setup we can use Weaviate\u0026rsquo;s docker-compose configurator to generate docker-compose.yml file for our specific need. We are going to use image to vector conversion so use the below config and download the docker-compose file. The docker-compose file will contain two services, weaviate (the VDB and Weavite APIs service) and the image to vector neural network service (resnet50 pytorch). Since we are using docker service for the ruby application as well combine all the services under one docker-compose file like,\n--- version: \u0026#39;3.4\u0026#39; services: weaviate: command: - --host - 0.0.0.0 - --port - \u0026#39;8080\u0026#39; - --scheme - http image: semitechnologies/weaviate:1.19.11 ports: - 8080:8080 restart: on-failure:0 volumes: - /var/weaviate:/var/lib/weaviate environment: IMAGE_INFERENCE_API: \u0026#39;http://i2v-neural:8080\u0026#39; QUERY_DEFAULTS_LIMIT: 25 AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: \u0026#39;true\u0026#39; PERSISTENCE_DATA_PATH: \u0026#39;/var/lib/weaviate\u0026#39; DEFAULT_VECTORIZER_MODULE: \u0026#39;img2vec-neural\u0026#39; ENABLE_MODULES: \u0026#39;img2vec-neural\u0026#39; CLUSTER_HOSTNAME: \u0026#39;node1\u0026#39; i2v-neural: image: semitechnologies/img2vec-pytorch:resnet50 environment: ENABLE_CUDA: \u0026#39;0\u0026#39; database: image: postgres container_name: database env_file: - .env volumes: - ./tmp/db:/var/lib/postgresql/data ports: - 6000:5432 fashion_products_vdb-web: container_name: fashion_products_vdb-web build: . depends_on: - database - weaviate - i2v-neural env_file: - .env command: bash -c \u0026#34;bundle \u0026amp;\u0026amp; rm -f /fashion_products_vdb/tmp/pids/server.pid \u0026amp;\u0026amp; rails db:prepare \u0026amp;\u0026amp; rails server -b 0.0.0.0\u0026#34; volumes: - .:/fashion_products_vdb # - ./dataset:/dataset # Use this volume setup one time for the image dataset import process ports: - 3012:3000 tty: true stdin_open: true ... By default the weaviate service does not contain any volumes option, we are adding the /var/weaviate:/var/lib/weaviate volume in order to persist the weaviate changes even after docker container restart.\nAfter the docker-compose file modifications run the docker-compose up command, it should download the images for the weaviate dependant services (note: the image sizes will be around 7GB for the resnet-50 image)\nNow add the weaviate-ruby gem to the project\u0026rsquo;s Gemfile,\n# Weaviate.io API ruby wrapper gem \u0026#34;weaviate-ruby\u0026#34; Create a library class to create Weaviate client instance for our application,\n# lib/weaviate_client.rb require \u0026#34;weaviate\u0026#34; class WeaviateClient # Creates a new WeaviateClient instance with the specified configuration def self.create_client Weaviate::Client.new( url: \u0026#34;http://weaviate:8080\u0026#34; # Use ENV variables ) end end Since we are using local docker setup we can use the port 8080 with weavite host for the client communication. Weaviate also provide\u0026rsquo;s cloud instances for which we need to generate API key for the client communication.\nAdd lib path to the application.rb -\u0026gt; autoload_path config as config.autoload_paths += %W(#{config.root}/lib) in order to load the class file to use in other parts of the application.\nNext create FashionProduct class schema using rails migration that will hold our FashionProduct product_image vectors and ID.\nrails g migration weaviate_create_fashion_product_class # db/migrate/20230706115924_weaviate_create_fashion_product_class.rb class WeaviateCreateFashionProductClass \u0026lt; ActiveRecord::Migration[7.0] def up class_name = \u0026#39;FashionProduct\u0026#39; # Name of the class (in vector DB) weaviate_client = WeaviateClient.create_client begin if weaviate_client.schema.get(class_name: class_name) != \u0026#34;Not Found\u0026#34; puts \u0026#34;Class \u0026#39;#{class_name}\u0026#39; already exists\u0026#34; return end weaviate_client.schema.create( class_name: class_name, vectorizer: \u0026#39;img2vec-neural\u0026#39;, # Module used to vectorize the images module_config: { \u0026#39;img2vec-neural\u0026#39;: { # Weaviate\u0026#39;s img2vec module \u0026#39;imageFields\u0026#39;: [ \u0026#39;image\u0026#39; ] } }, properties: [ # Properties of the VDB class { \u0026#39;name\u0026#39;: \u0026#39;image\u0026#39;, \u0026#39;dataType\u0026#39;: [\u0026#39;blob\u0026#39;] }, { \u0026#39;name\u0026#39;: \u0026#39;fashion_prd_id\u0026#39;, \u0026#39;dataType\u0026#39;: [\u0026#39;int\u0026#39;] } ] ) rescue =\u0026gt; exception if weaviate_client.schema.get(class_name: class_name) != \u0026#34;Not Found\u0026#34; weaviate_client.schema.delete(class_name: class_name) end raise exception end end def down weaviate_client = WeaviateClient.create_client if weaviate_client.schema.get(class_name: \u0026#39;FashionProduct\u0026#39;) != \u0026#34;Not Found\u0026#34; weaviate_client.schema.delete(class_name: \u0026#39;FashionProduct\u0026#39;) end end end Weaviate\u0026rsquo;s Schema contains the structure of the classes (similar to db tables). Each class contains properties (similar to table columns), we are using two properties image with blob datatype (to store the image vectors) and fashion_prd_id with integer datatype. If we want to delete a class under the schema along with all the data under the class we can use the schema - delete API as used in the down method of the migration.\nNow we will import the images to Weaviate DB. Using Weaviate objects batch create API we can import the image objects to Weaviate DB, the vector conversion of the images before storing will be handled by the Weaviate for which is uses the resnet-50 image APIs.\nCreate a one time rake to import the FashionProduct data into Weaviate DB.\ntask import_fashion_prd_data_to_weaviate: :environment do weaviate_client = WeaviateClient.create_client FashionProduct.find_in_batches(batch_size: 500) do |fpds| # Generate array with FashionProduct Base64 encoded image and ID values objects_to_upload = fpds.map do |fpd| { class: \u0026#39;FashionProduct\u0026#39;, properties: { image: Base64.strict_encode64(fpd.product_image_attachment.download).to_s, fashion_prd_id: fpd.id } } end # Weaviate.io objects API batch import p weaviate_client.objects.batch_create( objects: objects_to_upload ) end puts \u0026#34;-- Total FashionProduct records: #{FashionProduct.count}\u0026#34; uploaded_count = weaviate_client.query.aggs( class_name: \u0026#39;FashionProduct\u0026#39;, fields: \u0026#39;meta { count }\u0026#39;, ) puts \u0026#34;-- Total objects uploaded to Weaviate DB: #{uploaded_count}\u0026#34; end Now we are coming to the final stage, searching the image data with an image input. We will use the Weaviate client\u0026rsquo;s query API to get the matching image records, for which we will be passing a Base64 encoded image value for the near_image attribute.\nrequire \u0026#39;open-uri\u0026#39; weaviate_client_inst = WeaviateClient.create_client test_img_url = \u0026#39;\u0026lt;URL of the image\u0026gt;\u0026#39; base_64_img_string = Base64.strict_encode64(URI.parse(test_img_url).read) result = weaviate_client_inst.query.get( class_name: \u0026#39;FashionProduct\u0026#39;, limit: \u0026#39;5\u0026#39;, offset: \u0026#39;1\u0026#39;, near_image: \u0026#34;{ image: \\\u0026#34;#{base_64_img_string}\\\u0026#34; }\u0026#34;, fields: \u0026#39;fashion_prd_id\u0026#39; ) ## result [{\u0026#34;fashion_prd_id\u0026#34;=\u0026gt;10655}, {\u0026#34;fashion_prd_id\u0026#34;=\u0026gt;3077}, {\u0026#34;fashion_prd_id\u0026#34;=\u0026gt;207}, {\u0026#34;fashion_prd_id\u0026#34;=\u0026gt;11834}, {\u0026#34;fashion_prd_id\u0026#34;=\u0026gt;7883}] ## FashionProducts stored in application database FashionProduct.where(id: result.map { |prd_val| prd_val[\u0026#39;fashion_prd_id\u0026#39;] }) At last, we will build a simple UI that renders a form to get the image file from the user, and based on the search we will display all the matching FashionProduct items. Refer to the commits (FashionProducts UI dev and Image search controller with UI)\nConclusion ","permalink":"/posts/blog-setup/","summary":"\u003cp\u003eHave you ever wondered how to build an image search engine (like Google Images, Myntra fashion products search, etc,.)? In this blog post we will create a simple image search feature in the Ruby on Rails application using \u003ca href=\"https://weaviate.io/\"\u003eWeaviate\u003c/a\u003e vector database.\n\u003cimg alt=\"Image Description\" loading=\"lazy\" src=\"/images/KLQ29UJS.jpeg\"\u003e\u003c/p\u003e\n\u003cp\u003eThe modern approach to implementing image search involves \u003ca href=\"https://www.pinecone.io/learn/vector-embeddings-for-developers/\"\u003evector embeddings\u003c/a\u003e. Leveraging the magic of neural networks and vector databases, we\u0026rsquo;ll explore how to realize vector-based image searching.\u003c/p\u003e\n\u003cp\u003eThe popularity of vector search databases has skyrocketed recently, especially for vector conversion, storage, and retrieval tasks. In this blog post, we will specifically explore one such database called \u003ca href=\"https://weaviate.io/\"\u003eWeaviate\u003c/a\u003e, which offers neural network models like \u003ca href=\"https://blog.devgenius.io/resnet50-6b42934db431\"\u003eResnet-50\u003c/a\u003e(embedding model) for vectorization.\u003c/p\u003e","title":"Blog Setup"}]